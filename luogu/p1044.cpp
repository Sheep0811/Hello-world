#include<bits/stdc++.h>
int n;int f[20];
int main()
{
    scanf("%d",&n);
    f[0]=1,f[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<i;j++)
        {
            f[i]+=f[j]*f[i-j-1];
        }
    }
    printf("%d",f[n]);
    system ("pause");
    return 0;
}
/*看到大家的题解都写到了卡特兰数，但是没有细细的讲讲这跟本题有什么关系

本题的描述十分简单。n个数依次进栈，可随机出栈。求有几种可能。

dfs可以解，但是递推仿佛好像如同看上去貌似更简单一些。

解释一下原理：

建立数组f。f[i]表示i个数的全部可能性。

f[0] = 1, f[1] = 1; //当然只有一个

设 x 为当前出栈序列的最后一个，则x有n种取值

由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分

比x小

比x大

比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]

比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]

这两部分互相影响，所以一个x的取值能够得到的所有可能性为f[x-1] * f[n-x]

另外，由于x有n个取值，所以

ans = f[0]*f[n-1] + f[1]*f[n-2] + ... + f[n-1]*f[0];

这，就是传说中的卡特兰数*/
