# HTTP演变

## 1. HTTP/1.1相比HTTP/1.0

- 使用**TCP长连接**改善了1.0短连接造成的开销
- 支持管道网络传输，第一个请求发出去不必等其回来就可以发第二个（减少整体响应时间）

> 存在的问题：
>
> 1. pipeline 传输方式浏览器在处理时有各自问题和bug，所以一般默认也未开启支持。另外对于大文件依旧会存在服务器阻塞。
> 2. 主流用的还是keep-alive，在一个连接里资源的请求还是串行的，按请求顺序响应。为了加快并行速度浏览器会开多个连接，一个域名默认最多开约6个连接，超过限制数目的请求会被阻塞。（所以一些网站静态资源使用了多个域名，但域名太多管理不便且域名解析也需要时间）。
> 3. 只能客户端主动发起请求，不能服务器主动发起。
> 4. 请求/响应首部太大了，未经压缩就发送，浪费。
> 5. 每次请求/响应的首部大都是冗余的重复的内容。
> 6. 数据压缩非强制，可能存在未经压缩的情况。
> 7. 请求顺序没优先级，只能听天命(HTML资源顺序)。
> 8. 客户端可以解析html发送一个个的资源请求，服务器也能，但服务器无法自己知道请求的资源是什么。

## 2. Http2.0的改进

**处理核心**

- 希望链接用更多的并行处理。
- 服务器知道浏览器知道什么,然后一次性的给。

HTTP/2.0基于HTTPS（安全性有保障）

**优化**：

- **头部压缩**

- **二进制格式**

- **引入了帧（Frame）的概念**

  每一帧包含 Length + Type + Flags + StreamID + Payload 五部分，前四个部分是固定的长度，为 9 字节，第五部分 Payload 最大长度为 214 到 224-1 字节，即 16Kb 到 16 Mb，具体的最大长度由终端自行决定。

- **保留了请求和响应的概念**

  请求头和响应头会被发送方压缩后，分成几个连续的 Frame 传输，头字段会出现在这些 Frame 的 Payload 中；接收方拼合这些 Frame 后，解压缩后即可得到真正的请求头或响应头。

- **服务端推送**（Server Push）

  服务端可以主动向客户端发送信息，客户端拿到响应结果后可以保存，之后就不需要再发对应的请求了。

- **头部字段全部改为小写，不允许出现大写。**

- **数据流**

  数据包不按顺序发送，每个请求或回应的所有包称为一个数据流，客户端可以指定数据流优先级，1个 Stream 由双向传输的连续且有序的 Frame 组成，一个 TCP连接可以同时包含多个 Stream（比如 100 个），一个 Stream 只用于一次请求和一次响应。Stream 之间不会互相影响

- **多路复用**

  可以在一个连接中并发多个请求或回应，而不用按顺序一一对应解决了请求的对头阻塞

**存在的问题**

1. 多路复用解决了请求的对头阻塞，这是应用层上的，但服务器处理数据的阻塞（物理层的阻塞）没有解决。
2. 多个请求复用一个TCP连接，一旦丢包，会阻塞所有HTTP请求

## 3. HTTP/3

HTTP / 1.1和HTTP / 2使用TCP作为其传输。**HTTP / 3使用QUIC**，这是Google最初开发的一种基于UDP的传输层网络协议。改用QUIC的目的是解决HTTP / 2的一个主要问题HOL阻塞 (对头阻塞：head-of-line blocking) 。HTTP / 1.1中的HOL是指当浏览器中允许的并行请求数用完时，随后的请求需要等待前一个请求完成。HTTP / 2通过请求复用解决了此问题，该复用消除了应用程序层的HOL阻塞，但HOL仍存在于传输（TCP）层。

- 基于UDP的传输层协议：它使用UDP端口号来识别指定机器上的特定服务器。
- 可靠性：虽然UDP是不可靠传输协议，但是QUIC在UDP的基础上做了些改造，使得**他提供了和TCP类似的可靠性**。它提供了数据包重传、拥塞控制、调整传输节奏以及其他一些TCP中存在的特性。
- 实现了无序、并发字节流：**QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序**，这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同！
- 快速握手：**QUIC提供0-RTT和1-RTT的连接建立**
- 使用TLS 1.3传输层安全协议：与更早的TLS版本相比，TLS 1.3有着很多优点，但使用它的最主要原因是其握手所花费的往返次数更低，从而能降低协议的延迟。

# DNS over https

DNS做为互联网的基础服务历史已经太久了，应对现代网境暴露出过多的缺陷，主要有下面的问题：

1. **信息不加密，网络中间路由等都可以嗅探到通讯内容并可能篡改内容造成钓鱼诈骗和网络攻击**
2. **解析服务器不可信，污染和贩卖用户浏览记录层出不穷，造成用户隐私大量泄露，各种精准广告随之而来**
3. **通过解析识别会被防火墙识别，各种限流和屏蔽都很容易**

# Http Keep-alive和TCP Keepalive

**TCP keepalive**

正如上面提出的问题：**在双方长时间未通讯时，如何得知对方还活着？如何得知这个TCP连接是健康且具有通讯能力的？**

TCP的保活机制就是用来解决此类问题，这个机制我们也可以称作：keepalive。保活机制默认是关闭的，TCP连接的任何一方都可打开此功能。有三个主要配置参数用来控制保活功能。

如果在一段时间（**保活时间：tcp_keepalive_time**）内此连接都不活跃，开启保活功能的一端会向对端发送一个保活探测报文。

- 若对端正常存活，且连接有效，对端必然能收到探测报文并进行响应。此时，发送端收到响应报文则证明TCP连接正常，重置保活时间计数器即可。
- 若由于网络原因或其他原因导致，发送端无法正常收到保活探测报文的响应。那么在一定**探测时间间隔（tcp_keepalive_intvl）**后，将继续发送保活探测报文。直到收到对端的响应，或者达到配置的**探测循环次数上限（tcp_keepalive_probes）**都没有收到对端响应，这时对端会被认为不可达，TCP连接随存在但已失效，需要将连接做中断处理。

在探测过程中，对端主机会处于以下四种状态之一：

![img](https://pic4.zhimg.com/80/v2-837ba2a1eb7beb10c036ca468f7db69f_720w.jpg)

**HTTP keep-alive**

HTTP协议简介中提到http协议是一个运行在TCP协议之上的无状态的应用层协议。它的特点是：客户端的每一次请求都要和服务端创建TCP连接，服务器响应后，断开TCP连接。下次客户端再有请求，则重新建立连接。

在早期的http1.0中，默认就是上述介绍的这种“请求-应答”模式。这种方式频繁的创建连接和销毁连接无疑是有一定性能损耗的。

所以引入了**keep-alive**机制。http1.0默认是关闭的，通过http请求头设置“connection: keep-alive”进行开启；http1.1中默认开启，通过http请求头设置“connection: close”关闭。

**keep-alive**机制：若开启后，**在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。**在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。

**HTTP和TCP的长连接有何区别？HTTP中的keep-alive和TCP中keepalive又有什么区别？**

1、TCP连接往往就是我们广义理解上的长连接，因为它具备双端连续收发报文的能力；开启了keep-alive的HTTP连接，也是一种长连接，但是它由于协议本身的限制，服务端无法主动发起应用报文。

2、TCP中的keepalive是用来保鲜、保活的；HTTP中的keep-alive机制主要为了让支撑它的TCP连接活的的更久，所以通常又叫做：HTTP persistent connection（持久连接） 和 HTTP connection reuse（连接重用）。

## URL 编码（百分比编码）

URL 编码将字符转换为可通过因特网传输的格式。

URL 只能使用 [ASCII 字符集](https://www.w3school.com.cn/charsets/ref_html_ascii.asp) 通过因特网进行发送。

由于 URL 通常包含 ASCII 集之外的字符，因此必须将 URL 转换为有效的 ASCII 格式。

URL 编码使用后跟十六进制数字的 "%" 替代不安全的 ASCII 字符。

URL 不能包含空格。URL 编码通常使用加号（+）或 %20 替代空格。