# 面经

## 1.什么时候用map，什么时候用unordered_map？

* 需要有序性或者对单次查询有时间要求的应用场景下，应使用map，其余情况应使用unordered_map。  

## 2.tcp如何保证可靠传输

* 应用数据被分割成 TCP 认为最适合发送的数据块。
* TCP 给发送的每一个包进行**编号**，接收方对数据包进行排序，把有序数据传送给应用层。
* **校验和：**TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
* TCP 的接收端会丢弃重复的数据。
* **流量控制：**TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
* **拥塞控制：**当网络拥塞时，减少数据的发送。
* **ARQ协议：**也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
* **超时重传：**当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

## 3.C++的编译步骤，静态链接和动态链接区别？

* 在C/C++中，这些独立的编译单元包括obj文件（一般的源程序编译而成）、lib文件（静态链接的函数库）、dll文件（动态链接的函数库）等。

* 静态链接方式：在程序执行之前完成所有的组装工作，生成一个可执行的目标文件（EXE文件）。
* 动态链接方式：在程序已经为了执行被装入内存之后完成链接工作，并且在内存中一般只保留该编译单元的一份拷贝。

## 4.编译程序的步骤

* 词法分析——语法分析——语义分析——中间代码生成——代码优化——目标代码生成——目标程序

## 5.虚函数表存在哪里

* 一般分为五个区域：**栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区**
* 虚函数表存储在进程的只读数据段（**全局数据区/常量区**）。而虚函数则位于**代码段**（.text），也就是C++内存模型中的代码区。

* 虚函数表是属于类，类的所有对象共享这个类的虚函数表。并且，子类对象与指向子类的基类指针指向的对象，使用同一个虚函数表，符合C++的多态要求。

## 6.malloc分配内存策略

- 它有一个将可用的内存块连接为一个长长的列表的所谓**空闲链表**。
- 调用malloc函数时，它**沿连接表寻找一个大到足以满足用户请求所需要的内存块**。然后，**将该内存块一分为二**（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。
- 调用free函数时，**它将用户释放的内存块连接到空闲链上**。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，**将相邻的小空闲块合并成较大的内存块**。

## 7.C++编译后的函数符号和C语言编译后的函数符号有哪些区别？为什么

- C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为void func(int x,int y)。该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。 C++中提供了C连接交换指定符号 extern "C" 解决名字匹配问题。

## 8.c++中的几种锁

- **互斥锁（mutex）**
  可以避免多个线程在某一时刻同时操作一个共享资源，标准C++库提供了std::unique_lock类模板，实现了互斥锁的RAII惯用语法：	

​		`std::unique_lock<std::mutex> lk(mtx_sync_);`	

- **条件锁（condition_variable）**
  条件锁就是所谓的条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足了，即可唤醒该线程(常和互斥锁配合使用)，唤醒后，需要检查变量，避免虚假唤醒。

  ``` c++
  线程1：
  // wait ack
  {
      std::unique_lock<std::mutex> lk(mtx_sync_);
      if (!cv_sync_.wait_for(lk, 1000ms, [this](){return sync_; })) // wait for 1s
      {
          // wait failed
          printf("wait for notify timeout [%d].\n", cnt);
          return false;
      }
      else
      {
          return true;
      }
  }
  ```

  ~~~ c++
  线程2：
  {
  	std::unique_lock<std::mutex> lk(mtx_sync_);
  	sync_ = true;
  } // 通知前解锁，可以避免唤醒线程后由于互斥锁的关系又进入了阻塞阶段
  cv_sync_.notify_one();
  ~~~

  

* **自旋锁（不推荐使用）**
  自旋锁是一种基础的同步原语，用于保障对共享数据的互斥访问。与互斥锁的相比，在获取锁失败的时候不会使得线程阻塞而是一直自旋尝试获取锁。当线程等待自旋锁的时候，CPU不能做其他事情，而是一直处于轮询忙等的状态。自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。实际上许多其他类型的锁在底层使用了自旋锁实现，例如多数互斥锁在试图获取锁的时候会先自旋一小段时间，然后才会休眠。如果在持锁时间很长的场景下使用自旋锁，则会导致CPU在这个线程的时间片用尽之前一直消耗在无意义的忙等上，造成计算资源的浪费。// 用户空间用 atomic_flag 实现自旋互斥

~~~ c++
#include <thread>
#include <vector>
#include <iostream>
#include <atomic>

std::atomic_flag lock = ATOMIC_FLAG_INIT;

void f(int n)
{
    for (int cnt = 0; cnt < 100; ++cnt) {
        while (lock.test_and_set(std::memory_order_acquire))  // 获得锁
             ; // 自旋
        std::cout << "Output from thread " << n << '\n';
        lock.clear(std::memory_order_release);               // 释放锁
    }
}

int main()
{
    std::vector<std::thread> v;
    for (int n = 0; n < 10; ++n) {
        v.emplace_back(f, n);
    }
    for (auto& t : v) {
        t.join();
    }
}
~~~

* **递归锁（recursive_mutex）**
  recursive_mutex 类是同步原语，能用于保护共享数据免受从个多线程同时访问。

  recursive_mutex 提供排他性递归所有权语义：

  调用方线程在从它成功调用 lock 或 try_lock 开始的时期里占有 recursive_mutex 。此时期间，线程可以进行对 lock 或 try_lock 的附加调用。所有权的时期在线程调用 unlock 匹配次数时结束。
  线程占有 recursive_mutex 时，若其他所有线程试图要求 recursive_mutex 的所有权，则它们将阻塞（对于调用 lock ）或收到 false 返回值（对于调用 try_lock ）。
  可锁定 recursive_mutex 次数的最大值是未指定的，但抵达该数后，对 lock 的调用将抛出 std::system_error 而对 try_lock 的调用将返回 false 。
  若 recursive_mutex 在仍为某线程占有时被销毁，则程序行为未定义。 recursive_mutex 类满足互斥 (Mutex) 和标准布局类型 (StandardLayoutType) 的所有要求。

## 9.static和const可以同时修饰类成员函数吗？不可以

- const修饰的函数: 表示在该函数体内不能修改成员的值，会在函数中添加一个隐式的参数const this*.

- static修饰的函数没有this指针，与const的用法冲突。

## 10.进程间通信方式

> 常用的进程间通信方式：管道，共享内存，消息队列，信号量，套接字。

1. **管道**
   管道分为命名管道和匿名管道，命名管道可以用于两个或任意多个进程间通信，匿名管道则只能用于有血缘关系（父子进程、兄弟进程、爷孙进程等）的进程间通信。Linux中的“|”命令就是匿名管道，表示把一个进程的输出作为另一个进程的输入。管道就是内核里的一段缓存，从管道一端写入的数据实际上是缓存在内核中，从另一端读取也就是从内核中读取这段数据。管道是半双工的，数据只能向一个方向流动，双方需要互相通信时，需要建立起两个管道。

2. **共享内存**
   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的一种IPC方式，因为没有内存拷贝的操作，但需要依靠互斥锁或信号量来实现同步。

3. **信号**
   信号是Linux系统中的进程间通信方式，信号可以在任何时候发给某一进程，用于通知该进程某个事件已经发生。比如kill -9命令就可以向指定的进程发送一个终止信号从而杀死进程。

4. **信号量**
   信号量本质就是一个计数器，记录资源能被多少个进程同时访问，用来实现进程之间的互斥与同步，信号量的引入的是为了解决共享内存通信方式造成的进场安全问题。

5. **消息队列**
   多个不相干的进程可以通过一个消息队列来传递数据，且传递的是一个有意义的数据结构，而管道只能传递没有意义的字节流，还需要在接收端做解析。消息队列和管道一样是有一个buffer size限制的，当buffer size 为空或为满的时候，send和receive会sleep。ssize_t msgrrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);
   消息队列的目的是提供高于一般速度的IPC，但现在与其他形式的IPC相比，速度方面已经没有什么差别，在考虑到使用消息队列时遇到的问题，在新的应用程序中不应当再使用它们。

6. **套接字**
   可用于不同主机之间的进程间通信。

## 11.线程同步方式
对于多线程访问共享资源出现数据混乱的问题，需要进行线程同步。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。

> 常用的线程同步方式有四种：互斥锁、读写锁、条件变量、信号量。

1. **互斥锁**
   互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块，对于被锁定的这个代码块，所有的线程只能串行处理，不能并行处理。

- 相关函数：

``` c++
int pthread_mutex_init(pthread_mutex_t *restrict mutex, 
                        const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
                    //所有函数成功返回0，出错返回错误编号
```


在使用互斥量之前需要对它进行初始化，然后调用 pthread_mutex_lock 对互斥量上锁，若互斥量已经上锁，调用线程将阻塞直到互斥量被解锁，如果不希望线程被阻塞，可以调用 pthread_mutex_trylock 尝试对互斥量进行加锁，最后调用 pthread_mutex_unlock 对互斥量解锁。

2. **读写锁**
   读写锁是互斥锁的升级版，所有线程的读操作都是并行的，只有写操作是串行的。程序中的读操作越多，读写锁性能就越高，相反，若程序中全是写操作，那么读写锁会退化成互斥锁。

- 相关函数：

``` c++
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                            const pthread_rwlockattr_t *restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
                    //成功返回0，出错返回错误编号
```


可以指定加读锁或者写锁，不管以何种方式锁住读写锁，都可以调用 pthread_rwlock_unlock 进行解锁。

3. **条件变量**
   条件变量的主要作用不是处理线程同步，而是进行线程的阻塞。常常和互斥锁一起用在生产者和消费者模型中。举个例子：当任务队列为空时，消费者无法消费，使用条件变量把消费者线程阻塞住，等待生产者生产出任务后，再唤醒一个或多个被条件变量阻塞的消费者线程；反过来也可以控制生产者生产的上限，当任务队列达到一个上限值时用条件变量阻塞住生产者线程，直到消费者把任务消费后再唤醒被条件变量阻塞的生产者线程。

- 相关函数：

```c++
int pthread_cond_init(pthread_cond_t *restrict cond,
                        const pthread_condattr_t *restrict attr);
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
                    //成功返回0，出错返回错误编号
```

4. **信号量**
   信号量可以实现线程同步也可以实现进程同步，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要和互斥锁一起使用。信号量也可以用来实现生产者消费者模型，在用条件变量实现生产者消费者模型时需要自己做条件判断，而使用信号量就不需要。举个例子：初始化生产者的信号量为5，消费者的信号量为0，因为消费者信号量为0所以会被阻塞，生产者进行一次生产后会将自己的信号量减1，将消费者信号量加1，这时消费者解除阻塞，进行消费后再将自己的信号量减1生产者信号量加1。

- 相关函数：

  ``` c++
  int sem_init(sem_t* sem, int pshared, unsigned int value);  //信号量对象地址，是否多进程共享，初始状态下资源数量
  int sem_destroy(sem_t* sem);    //销毁信号量
  int sem_post(sem_t* sem);       //将信号量资源计数递增1并唤醒线程
  int sem_wait(sem_t* sem);       //若当前信号量为0，则阻塞线程，直到信号量对象的资源计数大于0时被唤醒，唤醒后资源计数递减1
  int sem_trywait(sem_t* sem);    //非阻塞版本
  int sem_timedwait(sem_t* sem, const struct timespec* abs_timeout);  //带等待时间的版本
  ```

5) **自旋锁**
自旋锁与互斥锁类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可用于一下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多成本。

- 相关函数：

  ```c++
  int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
  int pthread_spin_destroy(pthread_spinlock_t *lock);
  int pthread_spin_lock(pthread_spinlock_t *lock);
  int pthread_spin_trylock(pthread_spinlock_t *lock);
  int pthread_spin_unlock(pthread_spinlock_t *lock);
                      //成功返回0，出错返回错误编号
  ```

6)  **屏障**
屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出，但屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有线程达到屏障后可以接着工作。

- 函数原型：

  ```c++
  int pthread_barrier_init(pthread_barrier_t *restrict barrier,
          const pthread_barrierattr_t *restrict attr, unsigned int count);
  int pthread_barrier_destroy(pthread_barrier_t *barrier);
  int pthread_barrier_wait(pthread_barrier_t *barrier);
                      //成功返回0，出错返回错误编号
  ```


  count指定在允许所有线程继续运行之前，必须到达屏障的线程数目；
  调用pthread_barrier_wait的线程在屏障计数，未满足条件时会进入休眠状态。如果该线程是最后一个调用pthread_barrier_wait的线程，就满足了屏障计数，所有的线程都被唤醒。

- 补充一个死锁的概念：当多个线程访问共享资源时，需要加锁，如果锁使用不当，就会造成死锁，导致所有的线程都被阻塞，并且线程的阻塞无法解开。如果所有线程总是在对互斥量B加锁之前锁住互斥量A，那么使用这两个互斥量就不会产生死锁，可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住互斥量。
  造成死锁的场景有：
  ①、加锁后忘记解锁；
  ②、重复加锁造成死锁；
  ③、程序中存在多个共享资源，有多把锁，随意加锁导致相互被阻塞。
  解决方式：
  ①、多检查，避免重复加锁；
  ②、资源访问完毕后一定要解锁，或者在访问时使用trylock()，因为trylock()在加锁失败时不会一直阻塞，而是返回错误号。

## 12.僵尸进程

- 僵死进程，电脑术语。 是指子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其收尸，这个状态下的子进程就是僵死进程。

## 13. 右值引用

- 右值引用 eg `int &&a = move（b）不可以指向左值）

## 14. TIME_WAIT状态为什么是2MSL的时长？为什么不是等待其他时长？

- 考虑最坏的一种情况：第四次挥手的ACK包的最大生存时长(MSL)+服务端重传的FIN包的最大生存时长(MSL)=2MSL
- 确保被动关闭TCP连接的一端能收到第四次挥手的ACK
- 避免上一次TCP连接的数据包影响到下一次的TCP连接。

## 15. **命名管道与匿名管道的区别**

>  命名管道的特点是区别于匿名管道而言的，归纳起来主要有以下两点：

1. 匿名管道只能用于具有亲缘关系的两个进程间的通信，而命名管道可以用于任何两个进程间的通信，要灵活方便许多。

2. 命名管道虽然克服了匿名管道只能在具有亲缘关系的两个进程间使用的限制，但是并未克服匿名管道只能半双工通信的缺点。也就是说命名管道通常也是一种半双工通信方式。

3. 命名管道是一种特殊的文件类型，而且存在于文件系统中。所以，当通信进程使用完命名管道后，如果没有对其进行删除该文件依然存在。而匿名管道只存在于内存中，无法在文件系统中查看。

## 16. g++执行的四个过程 

1、**预处理**：条件编译，头文件包含，宏替换的处理，生成.i文件。

2、**编译**：将预处理后的文件转换成汇编语言，生成.s文件

3、**汇编**：汇编变为目标代码(机器代码)生成.o的文件

4、**链接**：连接目标代码,生成可执行程序

## 17.C++迭代器失效

**迭代器失效**的原因是：因为vetor、deque 使用了连续分配的内存， erase 操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有**迭代器**全部**失效**。

## 18.红黑树

**规则：**

红黑树除了符合二叉搜索树的基本规则外，还添加了以下特性：

> 规则1：节点是红色或黑色的；
>
> 规则2：根节点是黑色的；
>
> 规则3：每个叶子节点都是黑色的空节点（NIL节点）；
>
> 规则4：每个红色节点的两个子节点都是黑色的（从每个叶子到根的所有路径上不可能有两个连续的红色节点）；
>
> 规则5：从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点；

**红黑树的相对平衡**

这些约束确保了红黑树的关键特性: **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。**

因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

红黑树是平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。

为什么可以做到**最长路径不超过最短路径的两倍**呢？

- **性质4**决定了路径上不能有两个相连的红色节点；
- 所以，最长路径一定是红色节点和黑色节点交替而成的；
- 由于根节点和叶子节点都是黑色的，最短路径可能都是黑色节点，并且最长路径中一定是黑色节点多于红色节点；
- **性质5**决定了所有路径上都有相同数目的黑色节点；
- 这就表明了没有路径能多于其他任何路径两倍长。

### 红黑树的三种变换

插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换使树保持平衡：

- **变色**；
- **左旋转**；
- **右旋转**；

#### 2.1.变色

为了重新符合红黑树的规则，需要把**红色**节点变为**黑色**，或者把**黑色**节点变为**红色**；

插入的**新节点**通常都是**红色节点**：

- 当插入的节点为**红色**的时候，大多数情况**不违反**红黑树的任何规则；
- 而**插入黑色节点，**必然会导致一条路径上多了一个**黑色节点**，这是很难调整的；
- 红色节点虽然可能导致**红红相连**的情况，但是这种情况可以通过**颜色调换和旋转**来调整；

#### 2.2.左旋转

以节点X为根**逆时针**旋转二叉搜索树，使得父节点原来的位置被自己的右子节点替代，左子节点的位置被父节点替代；

[![image-20200303132706061](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/2.png)](https://gitee.com/ahuntsun/BlogImgs/raw/master/数据结构与算法/红黑树/2.png)

二叉搜索树左旋转之后仍为二叉搜索树：

[![image-20200303132617108](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/3.png)](https://gitee.com/ahuntsun/BlogImgs/raw/master/数据结构与算法/红黑树/3.png)

#### 2.3.右旋转

以节点X为根**顺时针**旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；

[![image-20200303132529476](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/4.png)](https://gitee.com/ahuntsun/BlogImgs/raw/master/数据结构与算法/红黑树/4.png)

二叉搜索树右旋转之后仍为二叉搜索树：

## 19.数据结构中各种树

[树](https://www.cnblogs.com/maybe2030/p/4732377.html)

###  **二叉树：**
 查找时间复杂度：最好：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn)),最差![O(n)](https://math.jianshu.com/math?formula=O(n))。最差情况是所有的数据全部在一端时。

### **二叉搜索树（二叉排序树、二叉查找树）：**
 查找时间复杂度：最好：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn)),最差![O(n)](https://math.jianshu.com/math?formula=O(n))。最差情况是所有的数据全部在一端时。

### **平衡二叉树：**

 查找时间复杂度：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn))

### **红黑树：**

 查找删除插入时间复杂度：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn))
 红黑树是一种自平衡的二叉排序树，它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。

### **B树：**

 一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，节点最大的孩子数目称为B树的阶。B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。B树所有叶子结点位于同一层。

###  **B+树：**

 B+树是B树的变体，也是一种多路搜索树。B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层. 其性能也等价于在关键字全集做一次二分查找；更适合文件索引系统。

### 为什么不用普通二叉树做索引？

因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。

### **为什么B+树比B树更适合文件索引和数据索引**

 B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对于B树更小，如果把所有同一内部节点的关键字放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存所需要查找的关键字也就越多，相对IO读写次数就降低了。

B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题,正是为了解决这个问题,B+树应用而生.B+树只需要去遍历叶子节点就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）.

b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；

### **字典树：**

字典树设计的核心思想是空间换时间，所以数据结构本身比较消耗空间。但它利用了字符串的**共同前缀（Common Prefix）**作为存储依据，以此来节省存储空间，并加速搜索时间。Trie 的字符串搜索时间复杂度为 **O(m)**，m 为最长的字符串的长度，其查询性能与集合中的字符串的数量无关。其在搜索字符串时表现出的高效，使得特别适用于构建文本搜索和词频统计等应用。

**字典树的性质**

1. 根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；
2. 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；
3. 任意节点的所有子节点所包含的字符都不相同；

如下图的 Trie 树中包含了字符串集合 ["Joe", "John", "Johnny", "Jane", "Jack"]。

![img](https://images0.cnblogs.com/blog/175043/201410/242258574966066.jpg)

Trie 关键词查找过程：

1. 每次从根结点开始搜索；
2. 获取关键词的第一个字符，根据该字符选择对应的子节点，转到该子节点继续检索；
3. 在相应的子节点上，获取关键词的第二个字符，进一步选择对应的子节点进行检索；
4. 以此类推，进行迭代过程；
5. 在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，查找完成。

关键词的插入和查找过程的时间复杂度均为 **O(key_length)**，空间复杂度 **O(ALPHABET_SIZE * key_length * N)** ，其中 N 是关键词的数量。 

**Trie 的应用**

- **字符串检索**：事先将已知的一些字符串（字典）的有关信息保存到 Trie 里，查找另外一些未知字符串是否出现过或者出现频率。
- **字符串最长公共前缀**：Trie 利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵 Trie 上时，我们可以快速得到某些字符串的公共前缀。
- **排序**：Trie 树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串，便是按字典序排序的结果。
- **作为其他数据结构和算法的辅助结构**：如后缀树，AC自动机等。

* 经常被搜索引擎系统用于文本词频统计。
* **优点**：利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。

## 20.**构造函数不能为虚函数，而析构函数可以且常常是虚函数。**

**1、构造函数不可以是虚函数**

当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。

虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。

vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。

如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。

因此，**构造函数不可以是虚函数**。

**2、析构函数常常是虚函数**

与构造函数不同，vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。

比如下面的例子：

```cpp
#include <iostream>
using namespace std;

class base {
public:
    base() {
        cout << "base constructor" << endl;
    }
    virtual ~base() {
        cout << "base destructor" << endl;
    }
};

class derived : public base {
public:
    derived() {
        cout << "derived constructor" << endl;
    }
    virtual ~derived() {
        cout << "derived destructor" << endl;
    }
};

int main()
{
    base *pBase = new derived;
    cout << "---" << endl;
    delete pBase;

    return 0;
}
```

运行结果为：

![img](https://pic4.zhimg.com/80/v2-66aa200f6e5511ef812c2d853fac1a73_720w.jpg)

若析构函数不是虚函数，则运行结果为：

![img](https://pic3.zhimg.com/80/v2-b51c46adb5094fc67202e8eb4f2f378e_720w.jpg)

可以看出：

- 若析构函数是虚函数，delete 时，基类和子类都会被释放；
- 若析构函数不是虚函数，delete 时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。

## 21.单例模式

## 22.get和post

|                  | GET                                                          | POST                                                         |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
| 缓存             | 能被缓存                                                     | 不能缓存                                                     |
| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded or multipart/form-data。为二进制数据使用多重编码。 |
| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |
| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |
| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。  在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |

## 23.减少上下文切换的方式

既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。

减少上下文切换的方法主要有无锁并发编程、CAS 算法、使用最少线程和使用协程。

- 无锁并发编程：多线程竞争时，会引起上下文切换（因为只有一个线程能进入临界区，获取锁失败的线程会被阻塞在临界区之外，线程此时挂起），所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据。
- CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。（这种方式思想同无锁并发编程一样，只不过这是一种具体的且常见的实现手段）
- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。（使用少量线程不止可以减少上下文切换，同时也减少了系统的开销）
- 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 24.外排序

**方法介绍**

所谓外排序，顾名思义，即是在内存外面的排序，因为当要处理的数据量很大，而不能一次装入内存时，此时只能放在读写较慢的外存储器（通常是硬盘）上。

外排序通常采用的是一种“排序-归并”的策略。

- 在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件；
- 尔后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。

假定现在有20个数据的文件A：{5 11 0 18 4 14 9 7 6 8 12 17 16 13 19 10 2 1 3 15}，但一次只能使用仅装4个数据的内容，所以，我们可以每趟对4个数据进行排序，即5路归并，具体方法如下述步骤：

- 我们先把“大”文件A，分割为a1，a2，a3，a4，a5等5个小文件，每个小文件4个数据
  - a1文件为：5 11 0 18
  - a2文件为：4 14 9 7
  - a3文件为：6 8 12 17
  - a4文件为：16 13 19 10
  - a5文件为：2 1 3 15
- 然后依次对5个小文件分别进行排序
  - a1文件完成排序后：0 5 11 18
  - a2文件完成排序后：4 7 9 14
  - a3文件完成排序后：6 8 12 17
  - a4文件完成排序后：10 13 16 19
  - a5文件完成排序后：1 2 3 15
- 最终多路归并，完成整个排序
  - 整个大文件A文件完成排序后：0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

**问题实例**

**1、给10^7个数据量的磁盘文件排序**

输入：给定一个文件，里面最多含有n个不重复的正整数（也就是说可能含有少于n个不重复正整数），且其中每个数都小于等于n，n=10^7。 输出：得到按从小到大升序排列的包含所有输入的整数的列表。 条件：最多有大约1MB的内存空间可用，但磁盘空间足够。且要求运行时间在5分钟以下，10秒为最佳结果。

**解法一**：位图方案

你可能会想到把磁盘文件进行归并排序，但题目要求你只有1MB的内存空间可用，所以，归并排序这个方法不行。

熟悉位图的朋友可能会想到用位图来表示这个文件集合。例如正如编程珠玑一书上所述，用一个20位长的字符串来表示一个所有元素都小于20的简单的非负整数集合，边框用如下字符串来表示集合{1,2,3,5,8,13}：

```
0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0
```

上述集合中各数对应的位置则置1，没有对应的数的位置则置0。

参考编程珠玑一书上的位图方案，针对我们的10^7个数据量的磁盘文件排序问题，我们可以这么考虑，由于每个7位十进制整数表示一个小于1000万的整数。我们可以使用一个具有1000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1。采取这个位图的方案是因为我们面对的这个问题的特殊性：

1. 输入数据限制在相对较小的范围内，
2. 数据没有重复，
3. 其中的每条记录都是单一的整数，没有任何其它与之关联的数据。

所以，此问题用位图的方案分为以下三步进行解决：

- 第一步，将所有的位都置为0，从而将集合初始化为空。
- 第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。
- 第三步，检验每一位，如果该位为1，就输出对应的整数。

经过以上三步后，产生有序的输出文件。令n为位图向量中的位数（本例中为1000 0000），程序可以用伪代码表示如下：

```
//磁盘文件排序位图方案的伪代码  
//copyright@ Jon Bentley  
//July、updated，2011.05.29。  

//第一步，将所有的位都初始化为0  
for i ={0,....n}      
   bit[i]=0;  
//第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。  
for each i in the input file     
   bit[i]=1;  

//第三步，检验每一位，如果该位为1，就输出对应的整数。  
for i={0...n}      
  if bit[i]==1        
    write i on the output file  
```

上述的位图方案，共需要扫描输入数据两次，具体执行步骤如下：

第一次，只处理1—4999999之间的数据，这些数都是小于5000000的，对这些数进行位图排序，只需要约5000000/8=625000Byte，也就是0.625M，排序后输出。 第二次，扫描输入文件时，只处理4999999-10000000的数据项，也只需要0.625M（可以使用第一次处理申请的内存）。 因此，总共也只需要0.625M 位图的的方法有必要强调一下，就是位图的适用范围为针对不重复的数据进行排序，若数据有重复，位图方案就不适用了。

不过很快，我们就将意识到，用此位图方法，严格说来还是不太行，空间消耗10^7/8还是大于1M（1M=1024*1024空间，小于10^7/8）。

既然如果用位图方案的话，我们需要约1.25MB（若每条记录是8位的正整数的话，则10000000/(1024*1024*8) ~= 1.2M）的空间，而现在只有1MB的可用存储空间，那么究竟该作何处理呢？

**解法二**：多路归并

诚然，在面对本题时，还可以通过计算分析出可以用如2的位图法解决，但实际上，很多的时候，我们都面临着这样一个问题，文件太大，无法一次性放入内存中计算处理，那这个时候咋办呢？分而治之，大而化小，也就是把整个大文件分为若干大小的几块，然后分别对每一块进行排序，最后完成整个过程的排序。k趟算法可以在kn的时间开销内和n/k的空间开销内完成对最多n个小于n的无重复正整数的排序。

比如可分为2块（k=2，1趟反正占用的内存只有1.25/2M），1~4999999，和5000000~9999999。先遍历一趟，首先排序处理1~4999999之间的整数（用5000000/8=625000个字的存储空间来排序0~4999999之间的整数），然后再第二趟，对5000001~1000000之间的整数进行排序处理。

**解法总结**

1、关于本章中位图和多路归并两种方案的时间复杂度及空间复杂度的比较，如下：

```
        时间复杂度        空间复杂度

位图          O(N)          0.625M

多位归并   O(Nlogn)             1M
```

（多路归并，时间复杂度为O（k*n/k*logn/k ），严格来说，还要加上读写磁盘的时间，而此算法绝大部分时间也是浪费在这上面）

2、bit-map

适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下

基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码

扩展：bloom filter可以看做是对bit-map的扩展

## 锁的类型

根据分类标准我们把锁分为以下 7 大类别，分别是：

- 偏向锁/轻量级锁/重量级锁；

- 可重入锁/非可重入锁；

  > 可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。

- 共享锁/独占锁；

  > 共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。

- 公平锁/非公平锁；

  > 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。

- 悲观锁/乐观锁；

  >  悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。

  **悲观锁**比较适合强一致性的**场景**，但效率比较低，特别是读的并发低。 **乐观锁**则适用于读多写少，并发冲突少的**场景**。

- 自旋锁/非自旋锁；

  > 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。

- 可中断锁/不可中断锁。

## 25. 线程池

池化思想:线程池、字符串常量池、数据库连接池

* 提高资源利用率  
* 正常流程：
  1. 手动创建线程对象
   2. 执行任务
   3. 执行完毕，释放线程对象
* 线程池优点
  1. 提高线程利用率
  2. 提高程序响应速度
  3. 便于统一管理线程对象
  4. 可以控制最大并发数

## 26.多线程

并发问题:并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种：

1. **竞态条件**：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。

2. **死锁**：并发程序等待一些必要资源，导致没有程序可以执行。
   + 必要条件：互斥，保持和请求，循环等待，不可剥夺。
3. **资源不足**：进程被永久剥夺了运行所需的资源。

